// Code generated by arcjet-gravity; DO NOT EDIT.

package records

import "context"
import "errors"
import "github.com/tetratelabs/wazero"
import "github.com/tetratelabs/wazero/api"

import _ "embed"

//go:embed records.wasm
var wasmFileRecords []byte

type IRecordsTypes interface {}

type Foo struct {
	Float32 float32

	Float64 float64

	Uint32 uint32

	Uint64 uint64

	S string

	Vf32 []float32

	Vf64 []float64
}

type Architecture uint
const (
	ArchitectureWasm32 Architecture = iota
	ArchitectureWasm64
)

func (a Architecture) PointerSize() uint32 {
	switch a {
	case ArchitectureWasm32:
		return 4
	case ArchitectureWasm64:
		return 8
	default:
		panic("invalid architecture")
	}
}

type RecordsFactoryOptions func(*RecordsFactory)

func RecordsFactoryWithArchitecture(architecture Architecture) RecordsFactoryOptions {
	return func(factory *RecordsFactory) {
		factory.architecture = architecture
	}
}

type RecordsFactory struct {
	runtime wazero.Runtime
	module wazero.CompiledModule
	architecture Architecture
}

func NewRecordsFactory(
	ctx context.Context,
	types IRecordsTypes,
	opts ...RecordsFactoryOptions,
) (*RecordsFactory, error) {
	wazeroRuntime := wazero.NewRuntime(ctx)
	// Compiling the module takes a LONG time, so we want to do it once and hold
	// onto it with the Runtime
	module, err := wazeroRuntime.CompileModule(ctx, wasmFileRecords)
	if err != nil {
		return nil, err
	}
	factory := &RecordsFactory{
		runtime: wazeroRuntime,
		module: module,
		// Initialize architecture to wasm32 by default
		architecture: ArchitectureWasm32,
	}

	for _, opt := range opts {
		opt(factory)
	}
	// Instantiate import host modules
	_, err0 := wazeroRuntime.NewHostModuleBuilder("arcjet:records/types").
	Instantiate(ctx)
	if err0 != nil {
		return nil, err0
	}

	return factory, nil
}

func (f *RecordsFactory) Instantiate(ctx context.Context) (*RecordsInstance, error) {
	if module, err := f.runtime.InstantiateModule(ctx, f.module, wazero.NewModuleConfig()); err != nil {
		return nil, err
	} else {
		return &RecordsInstance{module, f.architecture}, nil
	}
}

func (f *RecordsFactory) Close(ctx context.Context) {
	f.runtime.Close(ctx)
}

type RecordsInstance struct {
	module api.Module
	architecture Architecture
}

func (i *RecordsInstance) Close(ctx context.Context) error {
	if err := i.module.Close(ctx); err != nil {
		return err
	}

	return nil
}

// writeString will put a Go string into the Wasm memory following the Component
// Model calling conventions, such as allocating memory with the realloc function
func writeString(
	ctx context.Context,
	s string,
	memory api.Memory,
	realloc api.Function,
) (uint64, uint64, error) {
	if len(s) == 0 {
		return 1, 0, nil
	}

	results, err := realloc.Call(ctx, 0, 0, 1, uint64(len(s)))
	if err != nil {
		return 1, 0, err
	}
	ptr := results[0]
	ok := memory.Write(uint32(ptr), []byte(s))
	if !ok {
		return 1, 0, errors.New("failed to write string to wasm memory")
	}
	return uint64(ptr), uint64(len(s)), nil
}

func (i *RecordsInstance) ModifyFoo(
	ctx context.Context,
	f Foo,
) Foo {
	arg0 := f
	// GetArg { nth: 0 }
	// RecordLower { record: Record { fields: [Field { name: "float32", ty: F32, docs: Docs { contents: None } }, Field { name: "float64", ty: F64, docs: Docs { contents: None } }, Field { name: "uint32", ty: U32, docs: Docs { contents: None } }, Field { name: "uint64", ty: U64, docs: Docs { contents: None } }, Field { name: "s", ty: String, docs: Docs { contents: None } }, Field { name: "vf32", ty: Id(Id { idx: 0 }), docs: Docs { contents: None } }, Field { name: "vf64", ty: Id(Id { idx: 1 }), docs: Docs { contents: None } }] }, name: "foo", ty: Id { idx: 2 } }
	float320 := arg0.Float32
	float640 := arg0.Float64
	uint320 := arg0.Uint32
	uint640 := arg0.Uint64
	s0 := arg0.S
	vf320 := arg0.Vf32
	vf640 := arg0.Vf64
	// CoreF32FromF32
	result1 := api.EncodeF32(float32(float320))
	// CoreF64FromF64
	result2 := api.EncodeF64(float64(float640))
	// I32FromU32
	result3 := api.EncodeU32(uint320)
	// I64FromU64
	value4 := int64(uint640)
	// StringLower { realloc: Some("cabi_realloc") }
	memory5 := i.module.Memory()
	realloc5 := i.module.ExportedFunction("cabi_realloc")
	ptr5, len5, err5 := writeString(ctx, s0, memory5, realloc5)
	// The return type doesn't contain an error so we panic if one is encountered
	if err5 != nil {
		panic(err5)
	}
	// ListLower { element: F32, realloc: Some("cabi_realloc") }
	vec7 := vf320
	len7 := uint64(len(vec7))
	result7, err7 := i.module.ExportedFunction("cabi_realloc").Call(ctx, 0, 0, uint64(4), len7 * uint64(4))
	// The return type doesn't contain an error so we panic if one is encountered
	if err7 != nil {
		panic(err7)
	}
	ptr7 := result7[0]
	for idx := uint64(0); idx < len7; idx++ {
		e := vec7[idx]
		base := uint32(ptr7 + uint64(idx) * uint64(4))
		// IterElem { element: F32 }
		// IterBasePointer
		// CoreF32FromF32
		result6 := api.EncodeF32(float32(e))
		// F32Store { offset: 0 }
		i.module.Memory().WriteUint64Le(uint32(base)+uint32(0), result6)
	}
	// ListLower { element: F64, realloc: Some("cabi_realloc") }
	vec9 := vf640
	len9 := uint64(len(vec9))
	result9, err9 := i.module.ExportedFunction("cabi_realloc").Call(ctx, 0, 0, uint64(8), len9 * uint64(8))
	// The return type doesn't contain an error so we panic if one is encountered
	if err9 != nil {
		panic(err9)
	}
	ptr9 := result9[0]
	for idx := uint64(0); idx < len9; idx++ {
		e := vec9[idx]
		base := uint32(ptr9 + uint64(idx) * uint64(8))
		// IterElem { element: F64 }
		// IterBasePointer
		// CoreF64FromF64
		result8 := api.EncodeF64(float64(e))
		// F64Store { offset: 0 }
		i.module.Memory().WriteUint64Le(uint32(base)+uint32(0), result8)
	}
	// CallWasm { name: "modify-foo", sig: WasmSignature { params: [F32, F64, I32, I64, Pointer, Length, Pointer, Length, Pointer, Length], results: [Pointer], indirect_params: false, retptr: true } }
	raw10, err10 := i.module.ExportedFunction("modify-foo").Call(ctx, uint64(result1), uint64(result2), uint64(result3), uint64(value4), uint64(ptr5), uint64(len5), uint64(ptr7), uint64(len7), uint64(ptr9), uint64(len9))
	// The return type doesn't contain an error so we panic if one is encountered
	if err10 != nil {
		panic(err10)
	}

	// The cleanup via `cabi_post_*` cleans up the memory in the guest. By
	// deferring this, we ensure that no memory is corrupted before the function
	// is done accessing it.
	defer func() {
		if postFn := i.module.ExportedFunction("cabi_post_modify-foo"); postFn != nil {
			if _, err := postFn.Call(ctx, raw10...); err != nil {
				// If we get an error during cleanup, something really bad is
				// going on, so we panic. Also, you can't return the error from
				// the `defer`
				panic(errors.New("failed to cleanup"))
			}
		}
	}()

	results10 := raw10[0]
	// F32Load { offset: 0 }
	value11, ok11 := i.module.Memory().ReadUint64Le(uint32(results10) + uint32(0))
	// The return type doesn't contain an error so we panic if one is encountered
	if !ok11 {
		panic(errors.New("failed to read f64 from memory"))
	}
	// F32FromCoreF32
	result12 := api.DecodeF32(value11)
	// F64Load { offset: 8 }
	value13, ok13 := i.module.Memory().ReadUint64Le(uint32(results10) + uint32(8))
	// The return type doesn't contain an error so we panic if one is encountered
	if !ok13 {
		panic(errors.New("failed to read f64 from memory"))
	}
	// F64FromCoreF64
	result14 := api.DecodeF64(value13)
	// I32Load { offset: 16 }
	value15, ok15 := i.module.Memory().ReadUint32Le(uint32(results10) + uint32(16))
	// The return type doesn't contain an error so we panic if one is encountered
	if !ok15 {
		panic(errors.New("failed to read i32 from memory"))
	}
	// U32FromI32
	result16 := api.DecodeU32(uint64(value15))
	// I64Load { offset: 24 }
	value17, ok17 := i.module.Memory().ReadUint64Le(uint32(results10) + uint32(24))
	// The return type doesn't contain an error so we panic if one is encountered
	if !ok17 {
		panic(errors.New("failed to read i64 from memory"))
	}
	// U64FromI64
	value18 := uint64(value17)
	// PointerLoad { offset: 32 }
	var ptr19 uint64
	var ok19 bool
	switch i.architecture {
	case ArchitectureWasm64:
		ptr19, ok19 = i.module.Memory().ReadUint64Le(uint32(results10) + uint32(32))
	case ArchitectureWasm32:
		var tmpPtr19 uint32
		tmpPtr19, ok19 = i.module.Memory().ReadUint32Le(uint32(results10) + uint32(32))
		ptr19 = uint64(tmpPtr19)
	}
	// The return type doesn't contain an error so we panic if one is encountered
	if !ok19 {
		panic(errors.New("failed to read pointer from memory"))
	}
	// LengthLoad { offset: (32+1*ptrsz) }
	var len20 uint64
	var ok20 bool
	switch i.architecture {
	case ArchitectureWasm64:
		len20, ok20 = i.module.Memory().ReadUint64Le(uint32(results10) + uint32(32+1*i.architecture.PointerSize()))
	case ArchitectureWasm32:
		var tmpLen20 uint32
		tmpLen20, ok20 = i.module.Memory().ReadUint32Le(uint32(results10) + uint32(32+1*i.architecture.PointerSize()))
		len20 = uint64(tmpLen20)
	}
	// The return type doesn't contain an error so we panic if one is encountered
	if !ok20 {
		panic(errors.New("failed to read length from memory"))
	}
	// StringLift
	buf21, ok21 := i.module.Memory().Read(uint32(ptr19), uint32(len20))
	// The return type doesn't contain an error so we panic if one is encountered
	if !ok21 {
		panic(errors.New("failed to read bytes from memory"))
	}
	str21 := string(buf21)
	// PointerLoad { offset: (32+2*ptrsz) }
	var ptr22 uint64
	var ok22 bool
	switch i.architecture {
	case ArchitectureWasm64:
		ptr22, ok22 = i.module.Memory().ReadUint64Le(uint32(results10) + uint32((32+2*i.architecture.PointerSize())))
	case ArchitectureWasm32:
		var tmpPtr22 uint32
		tmpPtr22, ok22 = i.module.Memory().ReadUint32Le(uint32(results10) + uint32((32+2*i.architecture.PointerSize())))
		ptr22 = uint64(tmpPtr22)
	}
	// The return type doesn't contain an error so we panic if one is encountered
	if !ok22 {
		panic(errors.New("failed to read pointer from memory"))
	}
	// LengthLoad { offset: (32+3*ptrsz) }
	var len23 uint64
	var ok23 bool
	switch i.architecture {
	case ArchitectureWasm64:
		len23, ok23 = i.module.Memory().ReadUint64Le(uint32(results10) + uint32(32+3*i.architecture.PointerSize()))
	case ArchitectureWasm32:
		var tmpLen23 uint32
		tmpLen23, ok23 = i.module.Memory().ReadUint32Le(uint32(results10) + uint32(32+3*i.architecture.PointerSize()))
		len23 = uint64(tmpLen23)
	}
	// The return type doesn't contain an error so we panic if one is encountered
	if !ok23 {
		panic(errors.New("failed to read length from memory"))
	}
	// ListLift { element: F32, ty: Id { idx: 0 } }
	base26 := ptr22
	len26 := len23
	result26 := make([]float32, len26)
	for idx26 := uint64(0); idx26 < len26; idx26++ {
		base := base26 + idx26 * uint64(4)
		// IterBasePointer
		// F32Load { offset: 0 }
		value24, ok24 := i.module.Memory().ReadUint64Le(uint32(base) + uint32(0))
		// The return type doesn't contain an error so we panic if one is encountered
		if !ok24 {
			panic(errors.New("failed to read f64 from memory"))
		}
		// F32FromCoreF32
		result25 := api.DecodeF32(value24)
		result26[idx26] = result25
	}
	// PointerLoad { offset: (32+4*ptrsz) }
	var ptr27 uint64
	var ok27 bool
	switch i.architecture {
	case ArchitectureWasm64:
		ptr27, ok27 = i.module.Memory().ReadUint64Le(uint32(results10) + uint32((32+4*i.architecture.PointerSize())))
	case ArchitectureWasm32:
		var tmpPtr27 uint32
		tmpPtr27, ok27 = i.module.Memory().ReadUint32Le(uint32(results10) + uint32((32+4*i.architecture.PointerSize())))
		ptr27 = uint64(tmpPtr27)
	}
	// The return type doesn't contain an error so we panic if one is encountered
	if !ok27 {
		panic(errors.New("failed to read pointer from memory"))
	}
	// LengthLoad { offset: (32+5*ptrsz) }
	var len28 uint64
	var ok28 bool
	switch i.architecture {
	case ArchitectureWasm64:
		len28, ok28 = i.module.Memory().ReadUint64Le(uint32(results10) + uint32(32+5*i.architecture.PointerSize()))
	case ArchitectureWasm32:
		var tmpLen28 uint32
		tmpLen28, ok28 = i.module.Memory().ReadUint32Le(uint32(results10) + uint32(32+5*i.architecture.PointerSize()))
		len28 = uint64(tmpLen28)
	}
	// The return type doesn't contain an error so we panic if one is encountered
	if !ok28 {
		panic(errors.New("failed to read length from memory"))
	}
	// ListLift { element: F64, ty: Id { idx: 1 } }
	base31 := ptr27
	len31 := len28
	result31 := make([]float64, len31)
	for idx31 := uint64(0); idx31 < len31; idx31++ {
		base := base31 + idx31 * uint64(8)
		// IterBasePointer
		// F64Load { offset: 0 }
		value29, ok29 := i.module.Memory().ReadUint64Le(uint32(base) + uint32(0))
		// The return type doesn't contain an error so we panic if one is encountered
		if !ok29 {
			panic(errors.New("failed to read f64 from memory"))
		}
		// F64FromCoreF64
		result30 := api.DecodeF64(value29)
		result31[idx31] = result30
	}
	// RecordLift { record: Record { fields: [Field { name: "float32", ty: F32, docs: Docs { contents: None } }, Field { name: "float64", ty: F64, docs: Docs { contents: None } }, Field { name: "uint32", ty: U32, docs: Docs { contents: None } }, Field { name: "uint64", ty: U64, docs: Docs { contents: None } }, Field { name: "s", ty: String, docs: Docs { contents: None } }, Field { name: "vf32", ty: Id(Id { idx: 0 }), docs: Docs { contents: None } }, Field { name: "vf64", ty: Id(Id { idx: 1 }), docs: Docs { contents: None } }] }, name: "foo", ty: Id { idx: 2 } }
	value32 := Foo{
		Float32: result12,
		Float64: result14,
		Uint32: result16,
		Uint64: value18,
		S: str21,
		Vf32: result26,
		Vf64: result31,
	}
	// Flush { amt: 1 }
	// Return { amt: 1, func: Function { name: "modify-foo", kind: Freestanding, params: [("f", Id(Id { idx: 3 }))], result: Some(Id(Id { idx: 3 })), docs: Docs { contents: None }, stability: Unknown } }
	return value32
}

