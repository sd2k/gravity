// Code generated by arcjet-gravity; DO NOT EDIT.

// A basic component model world.
package basic

import "context"
import "errors"
import "github.com/tetratelabs/wazero"
import "github.com/tetratelabs/wazero/api"
import "reflect"

import _ "embed"

//go:embed basic.wasm
var wasmFileBasic []byte

// A logger interface.
type IBasicLogger interface {
	// Emit a log message at the debug level.
	Debug(
		ctx context.Context,
		msg string,
	)
	// Emit a log message at the info level.
	Info(
		ctx context.Context,
		msg string,
	)
	// Emit a log message at the warn level.
	Warn(
		ctx context.Context,
		msg string,
	)
	// Emit a log message at the error level.
	Error(
		ctx context.Context,
		msg string,
	)
}

type BasicFactory struct {
	runtime wazero.Runtime
	module wazero.CompiledModule
}

func NewBasicFactory(
	ctx context.Context,
	logger IBasicLogger,
) (*BasicFactory, error) {
	wazeroRuntime := wazero.NewRuntime(ctx)

	// Instantiate import host modules
	_, err0 := wazeroRuntime.NewHostModuleBuilder("arcjet:basic/logger").
	NewFunctionBuilder().
	WithFunc(func(
		ctx context.Context,
		mod api.Module,
		arg0 uint32,
		arg1 uint32,
	) {
		// GetArg { nth: 0 }
		// GetArg { nth: 1 }
		// StringLift
		buf0, ok0 := mod.Memory().Read(arg0, arg1)
		if !ok0 {
			panic(errors.New("failed to read bytes from memory"))
		}
		str0 := string(buf0)
		// CallInterface { func: Function { name: "debug", kind: Freestanding, params: [("msg", String)], result: None, docs: Docs { contents: Some("Emit a log message at the debug level.") }, stability: Unknown }, async_: false }
		logger.Debug(ctx, str0)
		// Return { amt: 0, func: Function { name: "debug", kind: Freestanding, params: [("msg", String)], result: None, docs: Docs { contents: Some("Emit a log message at the debug level.") }, stability: Unknown } }
	}).
	Export("debug").
	NewFunctionBuilder().
	WithFunc(func(
		ctx context.Context,
		mod api.Module,
		arg0 uint32,
		arg1 uint32,
	) {
		// GetArg { nth: 0 }
		// GetArg { nth: 1 }
		// StringLift
		buf0, ok0 := mod.Memory().Read(arg0, arg1)
		if !ok0 {
			panic(errors.New("failed to read bytes from memory"))
		}
		str0 := string(buf0)
		// CallInterface { func: Function { name: "info", kind: Freestanding, params: [("msg", String)], result: None, docs: Docs { contents: Some("Emit a log message at the info level.") }, stability: Unknown }, async_: false }
		logger.Info(ctx, str0)
		// Return { amt: 0, func: Function { name: "info", kind: Freestanding, params: [("msg", String)], result: None, docs: Docs { contents: Some("Emit a log message at the info level.") }, stability: Unknown } }
	}).
	Export("info").
	NewFunctionBuilder().
	WithFunc(func(
		ctx context.Context,
		mod api.Module,
		arg0 uint32,
		arg1 uint32,
	) {
		// GetArg { nth: 0 }
		// GetArg { nth: 1 }
		// StringLift
		buf0, ok0 := mod.Memory().Read(arg0, arg1)
		if !ok0 {
			panic(errors.New("failed to read bytes from memory"))
		}
		str0 := string(buf0)
		// CallInterface { func: Function { name: "warn", kind: Freestanding, params: [("msg", String)], result: None, docs: Docs { contents: Some("Emit a log message at the warn level.") }, stability: Unknown }, async_: false }
		logger.Warn(ctx, str0)
		// Return { amt: 0, func: Function { name: "warn", kind: Freestanding, params: [("msg", String)], result: None, docs: Docs { contents: Some("Emit a log message at the warn level.") }, stability: Unknown } }
	}).
	Export("warn").
	NewFunctionBuilder().
	WithFunc(func(
		ctx context.Context,
		mod api.Module,
		arg0 uint32,
		arg1 uint32,
	) {
		// GetArg { nth: 0 }
		// GetArg { nth: 1 }
		// StringLift
		buf0, ok0 := mod.Memory().Read(arg0, arg1)
		if !ok0 {
			panic(errors.New("failed to read bytes from memory"))
		}
		str0 := string(buf0)
		// CallInterface { func: Function { name: "error", kind: Freestanding, params: [("msg", String)], result: None, docs: Docs { contents: Some("Emit a log message at the error level.") }, stability: Unknown }, async_: false }
		logger.Error(ctx, str0)
		// Return { amt: 0, func: Function { name: "error", kind: Freestanding, params: [("msg", String)], result: None, docs: Docs { contents: Some("Emit a log message at the error level.") }, stability: Unknown } }
	}).
	Export("error").
	Instantiate(ctx)
	if err0 != nil {
		return nil, err0
	}

	// Compiling the module takes a LONG time, so we want to do it once and hold
	// onto it with the Runtime
	module, err := wazeroRuntime.CompileModule(ctx, wasmFileBasic)
	if err != nil {
		return nil, err
	}
	return &BasicFactory{
		runtime: wazeroRuntime,
		module: module,
	}, nil
}

func (f *BasicFactory) Instantiate(ctx context.Context) (*BasicInstance, error) {
	if module, err := f.runtime.InstantiateModule(ctx, f.module, wazero.NewModuleConfig()); err != nil {
		return nil, err
	} else {
		return &BasicInstance{module}, nil
	}
}

func (f *BasicFactory) Close(ctx context.Context) {
	f.runtime.Close(ctx)
}

type BasicInstance struct {
	module api.Module
}

func (i *BasicInstance) Close(ctx context.Context) error {
	if err := i.module.Close(ctx); err != nil {
		return err
	}

	return nil
}

// writeString will put a Go string into the Wasm memory following the Component
// Model calling conventions, such as allocating memory with the realloc function
func writeString(
	ctx context.Context,
	s string,
	memory api.Memory,
	realloc api.Function,
) (uint64, uint64, error) {
	if len(s) == 0 {
		return 1, 0, nil
	}

	results, err := realloc.Call(ctx, 0, 0, 1, uint64(len(s)))
	if err != nil {
		return 1, 0, err
	}
	ptr := results[0]
	ok := memory.Write(uint32(ptr), []byte(s))
	if !ok {
		return 1, 0, errors.New("failed to write string to wasm memory")
	}
	return uint64(ptr), uint64(len(s)), nil
}

func (i *BasicInstance) Hello(
	ctx context.Context,
) (string, error) {
	// CallWasm { name: "hello", sig: WasmSignature { params: [], results: [Pointer], indirect_params: false, retptr: true } }
	raw0, err0 := i.module.ExportedFunction("hello").Call(ctx, )
	if err0 != nil {
		var default0 string
		return default0, err0
	}

	// The cleanup via `cabi_post_*` cleans up the memory in the guest. By
	// deferring this, we ensure that no memory is corrupted before the function
	// is done accessing it.
	defer func() {
		if _, err := i.module.ExportedFunction("cabi_post_hello").Call(ctx, raw0...); err != nil {
			// If we get an error during cleanup, something really bad is
			// going on, so we panic. Also, you can't return the error from
			// the `defer`
			panic(errors.New("failed to cleanup"))
		}
	}()

	results0 := raw0[0]
	// I32Load8U { offset: 0 }
	value1, ok1 := i.module.Memory().ReadByte(uint32(results0 + 0))
	if !ok1 {
		var default1 string
		return default1, errors.New("failed to read byte from memory")
	}
	// ResultLift { result: Result_ { ok: Some(String), err: Some(String) }, ty: Id { idx: 0 } }
	var value8 string
	var err8 error
	switch value1 {
	case 0:
		// PointerLoad { offset: ptrsz }
		ptr2, ok2 := i.module.Memory().ReadUint32Le(uint32(results0 + 4))
		if !ok2 {
			var default2 string
			return default2, errors.New("failed to read pointer from memory")
		}
		// LengthLoad { offset: (2*ptrsz) }
		len3, ok3 := i.module.Memory().ReadUint32Le(uint32(results0 + 8))
		if !ok3 {
			var default3 string
			return default3, errors.New("failed to read length from memory")
		}
		// StringLift
		buf4, ok4 := i.module.Memory().Read(ptr2, len3)
		if !ok4 {
			var default4 string
			return default4, errors.New("failed to read bytes from memory")
		}
		str4 := string(buf4)
		value8 = str4
	case 1:
		// PointerLoad { offset: ptrsz }
		ptr5, ok5 := i.module.Memory().ReadUint32Le(uint32(results0 + 4))
		if !ok5 {
			var default5 string
			return default5, errors.New("failed to read pointer from memory")
		}
		// LengthLoad { offset: (2*ptrsz) }
		len6, ok6 := i.module.Memory().ReadUint32Le(uint32(results0 + 8))
		if !ok6 {
			var default6 string
			return default6, errors.New("failed to read length from memory")
		}
		// StringLift
		buf7, ok7 := i.module.Memory().Read(ptr5, len6)
		if !ok7 {
			var default7 string
			return default7, errors.New("failed to read bytes from memory")
		}
		str7 := string(buf7)
		err8 = errors.New(str7)
	default:
		err8 = errors.New("invalid variant discriminant for expected")
	}
	// Flush { amt: 1 }
	// Return { amt: 1, func: Function { name: "hello", kind: Freestanding, params: [], result: Some(Id(Id { idx: 0 })), docs: Docs { contents: Some("Say hello.") }, stability: Unknown } }
	return value8, err8
}

func (i *BasicInstance) Primitive(
	ctx context.Context,
) bool {
	// CallWasm { name: "primitive", sig: WasmSignature { params: [], results: [I32], indirect_params: false, retptr: false } }
	raw0, err0 := i.module.ExportedFunction("primitive").Call(ctx, )
	// The return type doesn't contain an error so we panic if one is encountered
	if err0 != nil {
		panic(err0)
	}

	results0 := raw0[0]
	// BoolFromI32
	value1 := results0 != 0
	// Return { amt: 1, func: Function { name: "primitive", kind: Freestanding, params: [], result: Some(Bool), docs: Docs { contents: Some("Just return a bool primitive.") }, stability: Unknown } }
	return value1
}

func (i *BasicInstance) OptionalPrimitive(
	ctx context.Context,
	b bool,
) (bool, bool) {
	arg0 := b
	// GetArg { nth: 0 }
	// OptionLower { payload: Bool, ty: Id { idx: 1 }, results: [I32, I32] }
	var variant1_0 uint32
	var variant1_1 uint32
	if reflect.ValueOf(arg0).IsZero() {
		// VariantPayloadName
		// I32Const { val: 0 }
		// ConstZero { tys: [I32] }
		variant1_0 = 0
		variant1_1 = 0
	} else {
		variantPayload := arg0
		// VariantPayloadName
		// I32Const { val: 1 }
		// I32FromBool
		var value0 uint32
		if variantPayload {
			value0 = 1
		} else {
			value0 = 0
		}
		variant1_0 = 1
		variant1_1 = value0
	}
	// CallWasm { name: "optional-primitive", sig: WasmSignature { params: [I32, I32], results: [Pointer], indirect_params: false, retptr: true } }
	raw2, err2 := i.module.ExportedFunction("optional-primitive").Call(ctx, uint64(variant1_0), uint64(variant1_1))
	// The return type doesn't contain an error so we panic if one is encountered
	if err2 != nil {
		panic(err2)
	}

	results2 := raw2[0]
	// I32Load8U { offset: 0 }
	value3, ok3 := i.module.Memory().ReadByte(uint32(results2 + 0))
	// The return type doesn't contain an error so we panic if one is encountered
	if !ok3 {
		panic(errors.New("failed to read byte from memory"))
	}
	// OptionLift { payload: Bool, ty: Id { idx: 1 } }
	var result6 bool
	var ok6 bool
	if value3 == 0 {
		ok6 = false
	} else {
		// I32Load8U { offset: 1 }
		value4, ok4 := i.module.Memory().ReadByte(uint32(results2 + 1))
		// The return type doesn't contain an error so we panic if one is encountered
		if !ok4 {
			panic(errors.New("failed to read byte from memory"))
		}
		// BoolFromI32
		value5 := value4 != 0
		ok6 = true
		result6 = value5
	}
	// Flush { amt: 1 }
	// Return { amt: 1, func: Function { name: "optional-primitive", kind: Freestanding, params: [("b", Id(Id { idx: 1 }))], result: Some(Id(Id { idx: 1 })), docs: Docs { contents: Some("Return an optional bool primitive.") }, stability: Unknown } }
	return result6, ok6
}

func (i *BasicInstance) ResultPrimitive(
	ctx context.Context,
) (bool, error) {
	// CallWasm { name: "result-primitive", sig: WasmSignature { params: [], results: [Pointer], indirect_params: false, retptr: true } }
	raw0, err0 := i.module.ExportedFunction("result-primitive").Call(ctx, )
	if err0 != nil {
		var default0 bool
		return default0, err0
	}

	// The cleanup via `cabi_post_*` cleans up the memory in the guest. By
	// deferring this, we ensure that no memory is corrupted before the function
	// is done accessing it.
	defer func() {
		if _, err := i.module.ExportedFunction("cabi_post_result-primitive").Call(ctx, raw0...); err != nil {
			// If we get an error during cleanup, something really bad is
			// going on, so we panic. Also, you can't return the error from
			// the `defer`
			panic(errors.New("failed to cleanup"))
		}
	}()

	results0 := raw0[0]
	// I32Load8U { offset: 0 }
	value1, ok1 := i.module.Memory().ReadByte(uint32(results0 + 0))
	if !ok1 {
		var default1 bool
		return default1, errors.New("failed to read byte from memory")
	}
	// ResultLift { result: Result_ { ok: Some(Bool), err: Some(String) }, ty: Id { idx: 2 } }
	var value7 bool
	var err7 error
	switch value1 {
	case 0:
		// I32Load8U { offset: ptrsz }
		value2, ok2 := i.module.Memory().ReadByte(uint32(results0 + 4))
		if !ok2 {
			var default2 bool
			return default2, errors.New("failed to read byte from memory")
		}
		// BoolFromI32
		value3 := value2 != 0
		value7 = value3
	case 1:
		// PointerLoad { offset: ptrsz }
		ptr4, ok4 := i.module.Memory().ReadUint32Le(uint32(results0 + 4))
		if !ok4 {
			var default4 bool
			return default4, errors.New("failed to read pointer from memory")
		}
		// LengthLoad { offset: (2*ptrsz) }
		len5, ok5 := i.module.Memory().ReadUint32Le(uint32(results0 + 8))
		if !ok5 {
			var default5 bool
			return default5, errors.New("failed to read length from memory")
		}
		// StringLift
		buf6, ok6 := i.module.Memory().Read(ptr4, len5)
		if !ok6 {
			var default6 bool
			return default6, errors.New("failed to read bytes from memory")
		}
		str6 := string(buf6)
		err7 = errors.New(str6)
	default:
		err7 = errors.New("invalid variant discriminant for expected")
	}
	// Flush { amt: 1 }
	// Return { amt: 1, func: Function { name: "result-primitive", kind: Freestanding, params: [], result: Some(Id(Id { idx: 2 })), docs: Docs { contents: Some("Return a result with an error.") }, stability: Unknown } }
	return value7, err7
}

func (i *BasicInstance) OptionalString(
	ctx context.Context,
	s string,
) (string, bool) {
	arg0 := s
	// GetArg { nth: 0 }
	// OptionLower { payload: String, ty: Id { idx: 3 }, results: [I32, Pointer, Length] }
	var variant1_0 uint32
	var variant1_1 uint64
	var variant1_2 uint64
	if reflect.ValueOf(arg0).IsZero() {
		// VariantPayloadName
		// I32Const { val: 0 }
		// ConstZero { tys: [Pointer, Length] }
		variant1_0 = 0
		variant1_1 = 0
		variant1_2 = 0
	} else {
		variantPayload := arg0
		// VariantPayloadName
		// I32Const { val: 1 }
		// StringLower { realloc: Some("cabi_realloc") }
		memory0 := i.module.Memory()
		realloc0 := i.module.ExportedFunction("cabi_realloc")
		ptr0, len0, err0 := writeString(ctx, variantPayload, memory0, realloc0)
		// The return type doesn't contain an error so we panic if one is encountered
		if err0 != nil {
			panic(err0)
		}
		variant1_0 = 1
		variant1_1 = ptr0
		variant1_2 = len0
	}
	// CallWasm { name: "optional-string", sig: WasmSignature { params: [I32, Pointer, Length], results: [Pointer], indirect_params: false, retptr: true } }
	raw2, err2 := i.module.ExportedFunction("optional-string").Call(ctx, uint64(variant1_0), uint64(variant1_1), uint64(variant1_2))
	// The return type doesn't contain an error so we panic if one is encountered
	if err2 != nil {
		panic(err2)
	}

	// The cleanup via `cabi_post_*` cleans up the memory in the guest. By
	// deferring this, we ensure that no memory is corrupted before the function
	// is done accessing it.
	defer func() {
		if _, err := i.module.ExportedFunction("cabi_post_optional-string").Call(ctx, raw2...); err != nil {
			// If we get an error during cleanup, something really bad is
			// going on, so we panic. Also, you can't return the error from
			// the `defer`
			panic(errors.New("failed to cleanup"))
		}
	}()

	results2 := raw2[0]
	// I32Load8U { offset: 0 }
	value3, ok3 := i.module.Memory().ReadByte(uint32(results2 + 0))
	// The return type doesn't contain an error so we panic if one is encountered
	if !ok3 {
		panic(errors.New("failed to read byte from memory"))
	}
	// OptionLift { payload: String, ty: Id { idx: 3 } }
	var result7 string
	var ok7 bool
	if value3 == 0 {
		ok7 = false
	} else {
		// PointerLoad { offset: ptrsz }
		ptr4, ok4 := i.module.Memory().ReadUint32Le(uint32(results2 + 4))
		// The return type doesn't contain an error so we panic if one is encountered
		if !ok4 {
			panic(errors.New("failed to read pointer from memory"))
		}
		// LengthLoad { offset: (2*ptrsz) }
		len5, ok5 := i.module.Memory().ReadUint32Le(uint32(results2 + 8))
		// The return type doesn't contain an error so we panic if one is encountered
		if !ok5 {
			panic(errors.New("failed to read length from memory"))
		}
		// StringLift
		buf6, ok6 := i.module.Memory().Read(ptr4, len5)
		// The return type doesn't contain an error so we panic if one is encountered
		if !ok6 {
			panic(errors.New("failed to read bytes from memory"))
		}
		str6 := string(buf6)
		ok7 = true
		result7 = str6
	}
	// Flush { amt: 1 }
	// Return { amt: 1, func: Function { name: "optional-string", kind: Freestanding, params: [("s", Id(Id { idx: 3 }))], result: Some(Id(Id { idx: 3 })), docs: Docs { contents: Some("Return an optional string.") }, stability: Unknown } }
	return result7, ok7
}

