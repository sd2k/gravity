// Code generated by arcjet-gravity; DO NOT EDIT.

package instructions

import "context"
import "github.com/tetratelabs/wazero"
import "github.com/tetratelabs/wazero/api"

import _ "embed"

//go:embed instructions.wasm
var wasmFileInstructions []byte

type InstructionsFactory struct {
	runtime wazero.Runtime
	module wazero.CompiledModule
}

func NewInstructionsFactory(
	ctx context.Context,
) (*InstructionsFactory, error) {
	wazeroRuntime := wazero.NewRuntime(ctx)

	// Compiling the module takes a LONG time, so we want to do it once and hold
	// onto it with the Runtime
	module, err := wazeroRuntime.CompileModule(ctx, wasmFileInstructions)
	if err != nil {
		return nil, err
	}
	return &InstructionsFactory{
		runtime: wazeroRuntime,
		module: module,
	}, nil
}

func (f *InstructionsFactory) Instantiate(ctx context.Context) (*InstructionsInstance, error) {
	if module, err := f.runtime.InstantiateModule(ctx, f.module, wazero.NewModuleConfig()); err != nil {
		return nil, err
	} else {
		return &InstructionsInstance{module}, nil
	}
}

func (f *InstructionsFactory) Close(ctx context.Context) {
	f.runtime.Close(ctx)
}

type InstructionsInstance struct {
	module api.Module
}

func (i *InstructionsInstance) Close(ctx context.Context) error {
	if err := i.module.Close(ctx); err != nil {
		return err
	}

	return nil
}

// writeString will put a Go string into the Wasm memory following the Component
// Model calling convetions, such as allocating memory with the realloc function
func writeString(
	ctx context.Context,
	s string,
	memory api.Memory,
	realloc api.Function,
) (uint64, uint64, error) {
	if len(s) == 0 {
		return 1, 0, nil
	}

	results, err := realloc.Call(ctx, 0, 0, 1, uint64(len(s)))
	if err != nil {
		return 1, 0, err
	}
	ptr := results[0]
	ok := memory.Write(uint32(ptr), []byte(s))
	if !ok {
		return 1, 0, err
	}
	return uint64(ptr), uint64(len(s)), nil
}

func (i *InstructionsInstance) S8Roundtrip(
	ctx context.Context,
	val int8,
) int8 {
	arg0 := val
	value0 := api.EncodeI32(int32(arg0))
	raw1, err1 := i.module.ExportedFunction("s8-roundtrip").Call(ctx, uint64(value0))
	// The return type doesn't contain an error so we panic if one is encountered
	if err1 != nil {
		panic(err1)
	}

	results1 := raw1[0]
	result2 := int8(api.DecodeI32(results1))
	return result2
}

func (i *InstructionsInstance) U8Roundtrip(
	ctx context.Context,
	val uint8,
) uint8 {
	arg0 := val
	value0 := api.EncodeI32(int32(arg0))
	raw1, err1 := i.module.ExportedFunction("u8-roundtrip").Call(ctx, uint64(value0))
	// The return type doesn't contain an error so we panic if one is encountered
	if err1 != nil {
		panic(err1)
	}

	results1 := raw1[0]
	result2 := uint8(api.DecodeU32(results1))
	return result2
}

func (i *InstructionsInstance) S16Roundtrip(
	ctx context.Context,
	val int16,
) int16 {
	arg0 := val
	value0 := api.EncodeI32(int32(arg0))
	raw1, err1 := i.module.ExportedFunction("s16-roundtrip").Call(ctx, uint64(value0))
	// The return type doesn't contain an error so we panic if one is encountered
	if err1 != nil {
		panic(err1)
	}

	results1 := raw1[0]
	result2 := int16(api.DecodeI32(results1))
	return result2
}

func (i *InstructionsInstance) U16Roundtrip(
	ctx context.Context,
	val uint16,
) uint16 {
	arg0 := val
	value0 := api.EncodeI32(int32(arg0))
	raw1, err1 := i.module.ExportedFunction("u16-roundtrip").Call(ctx, uint64(value0))
	// The return type doesn't contain an error so we panic if one is encountered
	if err1 != nil {
		panic(err1)
	}

	results1 := raw1[0]
	result2 := uint16(api.DecodeU32(results1))
	return result2
}

func (i *InstructionsInstance) S32Roundtrip(
	ctx context.Context,
	val int32,
) int32 {
	arg0 := val
	value0 := api.EncodeI32(arg0)
	raw1, err1 := i.module.ExportedFunction("s32-roundtrip").Call(ctx, uint64(value0))
	// The return type doesn't contain an error so we panic if one is encountered
	if err1 != nil {
		panic(err1)
	}

	results1 := raw1[0]
	result2 := api.DecodeI32(results1)
	return result2
}

func (i *InstructionsInstance) U32Roundtrip(
	ctx context.Context,
	val uint32,
) uint32 {
	arg0 := val
	result0 := api.EncodeU32(arg0)
	raw1, err1 := i.module.ExportedFunction("u32-roundtrip").Call(ctx, uint64(result0))
	// The return type doesn't contain an error so we panic if one is encountered
	if err1 != nil {
		panic(err1)
	}

	results1 := raw1[0]
	result2 := api.DecodeU32(results1)
	return result2
}

func (i *InstructionsInstance) F32Roundtrip(
	ctx context.Context,
	val float32,
) float32 {
	arg0 := val
	result0 := api.EncodeF32(arg0)
	raw1, err1 := i.module.ExportedFunction("f32-roundtrip").Call(ctx, uint64(result0))
	// The return type doesn't contain an error so we panic if one is encountered
	if err1 != nil {
		panic(err1)
	}

	results1 := raw1[0]
	result2 := api.DecodeF32(results1)
	return result2
}

func (i *InstructionsInstance) F64Roundtrip(
	ctx context.Context,
	val float64,
) float64 {
	arg0 := val
	result0 := api.EncodeF64(arg0)
	raw1, err1 := i.module.ExportedFunction("f64-roundtrip").Call(ctx, uint64(result0))
	// The return type doesn't contain an error so we panic if one is encountered
	if err1 != nil {
		panic(err1)
	}

	results1 := raw1[0]
	result2 := api.DecodeF64(results1)
	return result2
}

