// Code generated by arcjet-gravity; DO NOT EDIT.

package instructions

import "context"
import "errors"
import "github.com/tetratelabs/wazero"
import "github.com/tetratelabs/wazero/api"

import _ "embed"

//go:embed instructions.wasm
var wasmFileInstructions []byte

type InstructionsFactory struct {
	runtime wazero.Runtime
	module wazero.CompiledModule
}

func NewInstructionsFactory(
	ctx context.Context,
) (*InstructionsFactory, error) {
	wazeroRuntime := wazero.NewRuntime(ctx)

	// Compiling the module takes a LONG time, so we want to do it once and hold
	// onto it with the Runtime
	module, err := wazeroRuntime.CompileModule(ctx, wasmFileInstructions)
	if err != nil {
		return nil, err
	}
	return &InstructionsFactory{
		runtime: wazeroRuntime,
		module: module,
	}, nil
}

func (f *InstructionsFactory) Instantiate(ctx context.Context) (*InstructionsInstance, error) {
	if module, err := f.runtime.InstantiateModule(ctx, f.module, wazero.NewModuleConfig()); err != nil {
		return nil, err
	} else {
		return &InstructionsInstance{module}, nil
	}
}

func (f *InstructionsFactory) Close(ctx context.Context) {
	f.runtime.Close(ctx)
}

type InstructionsInstance struct {
	module api.Module
}

func (i *InstructionsInstance) Close(ctx context.Context) error {
	if err := i.module.Close(ctx); err != nil {
		return err
	}

	return nil
}

// writeString will put a Go string into the Wasm memory following the Component
// Model calling conventions, such as allocating memory with the realloc function
func writeString(
	ctx context.Context,
	s string,
	memory api.Memory,
	realloc api.Function,
) (uint64, uint64, error) {
	if len(s) == 0 {
		return 1, 0, nil
	}

	results, err := realloc.Call(ctx, 0, 0, 1, uint64(len(s)))
	if err != nil {
		return 1, 0, err
	}
	ptr := results[0]
	ok := memory.Write(uint32(ptr), []byte(s))
	if !ok {
		return 1, 0, errors.New("failed to write string to wasm memory")
	}
	return uint64(ptr), uint64(len(s)), nil
}

func (i *InstructionsInstance) S8Roundtrip(
	ctx context.Context,
	val int8,
) int8 {
	arg0 := val
	// GetArg { nth: 0 }
	// I32FromS8
	value0 := api.EncodeI32(int32(arg0))
	// CallWasm { name: "s8-roundtrip", sig: WasmSignature { params: [I32], results: [I32], indirect_params: false, retptr: false } }
	raw1, err1 := i.module.ExportedFunction("s8-roundtrip").Call(ctx, uint64(value0))
	// The return type doesn't contain an error so we panic if one is encountered
	if err1 != nil {
		panic(err1)
	}

	results1 := raw1[0]
	// S8FromI32
	result2 := int8(api.DecodeI32(results1))
	// Return { amt: 1, func: Function { name: "s8-roundtrip", kind: Freestanding, params: [("val", S8)], result: Some(S8), docs: Docs { contents: None }, stability: Unknown } }
	return result2
}

func (i *InstructionsInstance) U8Roundtrip(
	ctx context.Context,
	val uint8,
) uint8 {
	arg0 := val
	// GetArg { nth: 0 }
	// I32FromU8
	value0 := api.EncodeI32(int32(arg0))
	// CallWasm { name: "u8-roundtrip", sig: WasmSignature { params: [I32], results: [I32], indirect_params: false, retptr: false } }
	raw1, err1 := i.module.ExportedFunction("u8-roundtrip").Call(ctx, uint64(value0))
	// The return type doesn't contain an error so we panic if one is encountered
	if err1 != nil {
		panic(err1)
	}

	results1 := raw1[0]
	// U8FromI32
	result2 := uint8(api.DecodeU32(results1))
	// Return { amt: 1, func: Function { name: "u8-roundtrip", kind: Freestanding, params: [("val", U8)], result: Some(U8), docs: Docs { contents: None }, stability: Unknown } }
	return result2
}

func (i *InstructionsInstance) S16Roundtrip(
	ctx context.Context,
	val int16,
) int16 {
	arg0 := val
	// GetArg { nth: 0 }
	// I32FromS16
	value0 := api.EncodeI32(int32(arg0))
	// CallWasm { name: "s16-roundtrip", sig: WasmSignature { params: [I32], results: [I32], indirect_params: false, retptr: false } }
	raw1, err1 := i.module.ExportedFunction("s16-roundtrip").Call(ctx, uint64(value0))
	// The return type doesn't contain an error so we panic if one is encountered
	if err1 != nil {
		panic(err1)
	}

	results1 := raw1[0]
	// S16FromI32
	result2 := int16(api.DecodeI32(results1))
	// Return { amt: 1, func: Function { name: "s16-roundtrip", kind: Freestanding, params: [("val", S16)], result: Some(S16), docs: Docs { contents: None }, stability: Unknown } }
	return result2
}

func (i *InstructionsInstance) U16Roundtrip(
	ctx context.Context,
	val uint16,
) uint16 {
	arg0 := val
	// GetArg { nth: 0 }
	// I32FromU16
	value0 := api.EncodeI32(int32(arg0))
	// CallWasm { name: "u16-roundtrip", sig: WasmSignature { params: [I32], results: [I32], indirect_params: false, retptr: false } }
	raw1, err1 := i.module.ExportedFunction("u16-roundtrip").Call(ctx, uint64(value0))
	// The return type doesn't contain an error so we panic if one is encountered
	if err1 != nil {
		panic(err1)
	}

	results1 := raw1[0]
	// U16FromI32
	result2 := uint16(api.DecodeU32(results1))
	// Return { amt: 1, func: Function { name: "u16-roundtrip", kind: Freestanding, params: [("val", U16)], result: Some(U16), docs: Docs { contents: None }, stability: Unknown } }
	return result2
}

func (i *InstructionsInstance) S32Roundtrip(
	ctx context.Context,
	val int32,
) int32 {
	arg0 := val
	// GetArg { nth: 0 }
	// I32FromS32
	value0 := api.EncodeI32(arg0)
	// CallWasm { name: "s32-roundtrip", sig: WasmSignature { params: [I32], results: [I32], indirect_params: false, retptr: false } }
	raw1, err1 := i.module.ExportedFunction("s32-roundtrip").Call(ctx, uint64(value0))
	// The return type doesn't contain an error so we panic if one is encountered
	if err1 != nil {
		panic(err1)
	}

	results1 := raw1[0]
	// S32FromI32
	result2 := api.DecodeI32(results1)
	// Return { amt: 1, func: Function { name: "s32-roundtrip", kind: Freestanding, params: [("val", S32)], result: Some(S32), docs: Docs { contents: None }, stability: Unknown } }
	return result2
}

func (i *InstructionsInstance) U32Roundtrip(
	ctx context.Context,
	val uint32,
) uint32 {
	arg0 := val
	// GetArg { nth: 0 }
	// I32FromU32
	result0 := api.EncodeU32(arg0)
	// CallWasm { name: "u32-roundtrip", sig: WasmSignature { params: [I32], results: [I32], indirect_params: false, retptr: false } }
	raw1, err1 := i.module.ExportedFunction("u32-roundtrip").Call(ctx, uint64(result0))
	// The return type doesn't contain an error so we panic if one is encountered
	if err1 != nil {
		panic(err1)
	}

	results1 := raw1[0]
	// U32FromI32
	result2 := api.DecodeU32(uint64(results1))
	// Return { amt: 1, func: Function { name: "u32-roundtrip", kind: Freestanding, params: [("val", U32)], result: Some(U32), docs: Docs { contents: None }, stability: Unknown } }
	return result2
}

func (i *InstructionsInstance) F32Roundtrip(
	ctx context.Context,
	val float32,
) float32 {
	arg0 := val
	// GetArg { nth: 0 }
	// CoreF32FromF32
	result0 := api.EncodeF32(float32(arg0))
	// CallWasm { name: "f32-roundtrip", sig: WasmSignature { params: [F32], results: [F32], indirect_params: false, retptr: false } }
	raw1, err1 := i.module.ExportedFunction("f32-roundtrip").Call(ctx, uint64(result0))
	// The return type doesn't contain an error so we panic if one is encountered
	if err1 != nil {
		panic(err1)
	}

	results1 := raw1[0]
	// F32FromCoreF32
	result2 := api.DecodeF32(results1)
	// Return { amt: 1, func: Function { name: "f32-roundtrip", kind: Freestanding, params: [("val", F32)], result: Some(F32), docs: Docs { contents: None }, stability: Unknown } }
	return result2
}

func (i *InstructionsInstance) F64Roundtrip(
	ctx context.Context,
	val float64,
) float64 {
	arg0 := val
	// GetArg { nth: 0 }
	// CoreF64FromF64
	result0 := api.EncodeF64(float64(arg0))
	// CallWasm { name: "f64-roundtrip", sig: WasmSignature { params: [F64], results: [F64], indirect_params: false, retptr: false } }
	raw1, err1 := i.module.ExportedFunction("f64-roundtrip").Call(ctx, uint64(result0))
	// The return type doesn't contain an error so we panic if one is encountered
	if err1 != nil {
		panic(err1)
	}

	results1 := raw1[0]
	// F64FromCoreF64
	result2 := api.DecodeF64(results1)
	// Return { amt: 1, func: Function { name: "f64-roundtrip", kind: Freestanding, params: [("val", F64)], result: Some(F64), docs: Docs { contents: None }, stability: Unknown } }
	return result2
}

