// Code generated by arcjet-gravity; DO NOT EDIT.

package tuples

import "context"
import "errors"
import "github.com/tetratelabs/wazero"
import "github.com/tetratelabs/wazero/api"

import _ "embed"

//go:embed tuples.wasm
var wasmFileTuples []byte

type ITuplesTypes interface {}

type CustomTuple struct {
	F0 uint32

	F1 float64

	F2 string
}

type TuplesFactory struct {
	runtime wazero.Runtime
	module wazero.CompiledModule
}

func NewTuplesFactory(
	ctx context.Context,
	types ITuplesTypes,
) (*TuplesFactory, error) {
	wazeroRuntime := wazero.NewRuntime(ctx)

	// Instantiate import host modules
	_, err0 := wazeroRuntime.NewHostModuleBuilder("arcjet:tuples/types").
	Instantiate(ctx)
	if err0 != nil {
		return nil, err0
	}

	// Compiling the module takes a LONG time, so we want to do it once and hold
	// onto it with the Runtime
	module, err := wazeroRuntime.CompileModule(ctx, wasmFileTuples)
	if err != nil {
		return nil, err
	}
	return &TuplesFactory{
		runtime: wazeroRuntime,
		module: module,
	}, nil
}

func (f *TuplesFactory) Instantiate(ctx context.Context) (*TuplesInstance, error) {
	if module, err := f.runtime.InstantiateModule(ctx, f.module, wazero.NewModuleConfig()); err != nil {
		return nil, err
	} else {
		return &TuplesInstance{module}, nil
	}
}

func (f *TuplesFactory) Close(ctx context.Context) {
	f.runtime.Close(ctx)
}

type TuplesInstance struct {
	module api.Module
}

func (i *TuplesInstance) Close(ctx context.Context) error {
	if err := i.module.Close(ctx); err != nil {
		return err
	}

	return nil
}

// writeString will put a Go string into the Wasm memory following the Component
// Model calling convetions, such as allocating memory with the realloc function
func writeString(
	ctx context.Context,
	s string,
	memory api.Memory,
	realloc api.Function,
) (uint64, uint64, error) {
	if len(s) == 0 {
		return 1, 0, nil
	}

	results, err := realloc.Call(ctx, 0, 0, 1, uint64(len(s)))
	if err != nil {
		return 1, 0, err
	}
	ptr := results[0]
	ok := memory.Write(uint32(ptr), []byte(s))
	if !ok {
		return 1, 0, err
	}
	return uint64(ptr), uint64(len(s)), nil
}

func (i *TuplesInstance) CustomTupleFunc(
	ctx context.Context,
	t CustomTuple,
) CustomTuple {
	arg0 := t
	// GetArg { nth: 0 }
	// TupleLower { tuple: Tuple { types: [U32, F64, String] }, ty: Id { idx: 0 } }
	f00 := arg0.F0
	f01 := arg0.F1
	f02 := arg0.F2
	// I32FromU32
	result1 := api.EncodeU32(f00)
	// CoreF64FromF64
	result2 := api.EncodeF64(float64(f01))
	// StringLower { realloc: Some("cabi_realloc") }
	memory3 := i.module.Memory()
	realloc3 := i.module.ExportedFunction("cabi_realloc")
	ptr3, len3, err3 := writeString(ctx, f02, memory3, realloc3)
	// The return type doesn't contain an error so we panic if one is encountered
	if err3 != nil {
		panic(err3)
	}
	// CallWasm { name: "custom-tuple-func", sig: WasmSignature { params: [I32, F64, Pointer, Length], results: [Pointer], indirect_params: false, retptr: true } }
	raw4, err4 := i.module.ExportedFunction("custom-tuple-func").Call(ctx, uint64(result1), uint64(result2), uint64(ptr3), uint64(len3))
	// The return type doesn't contain an error so we panic if one is encountered
	if err4 != nil {
		panic(err4)
	}

	// The cleanup via `cabi_post_*` cleans up the memory in the guest. By
	// deferring this, we ensure that no memory is corrupted before the function
	// is done accessing it.
	defer func() {
		if _, err := i.module.ExportedFunction("cabi_post_custom-tuple-func").Call(ctx, raw4...); err != nil {
			// If we get an error during cleanup, something really bad is
			// going on, so we panic. Also, you can't return the error from
			// the `defer`
			panic(errors.New("failed to cleanup"))
		}
	}()

	results4 := raw4[0]
	// I32Load { offset: 0 }
	value5, ok5 := i.module.Memory().ReadUint32Le(uint32(results4 + 0))
	// The return type doesn't contain an error so we panic if one is encountered
	if !ok5 {
		panic(errors.New("failed to read i32 from memory"))
	}
	// U32FromI32
	result6 := api.DecodeU32(uint64(value5))
	// F64Load { offset: 8 }
	value7, ok7 := i.module.Memory().ReadUint64Le(uint32(results4 + 8))
	// The return type doesn't contain an error so we panic if one is encountered
	if !ok7 {
		panic(errors.New("failed to read f64 from memory"))
	}
	// F64FromCoreF64
	result8 := api.DecodeF64(value7)
	// PointerLoad { offset: 16 }
	ptr9, ok9 := i.module.Memory().ReadUint32Le(uint32(results4 + 16))
	// The return type doesn't contain an error so we panic if one is encountered
	if !ok9 {
		panic(errors.New("failed to read pointer from memory"))
	}
	// LengthLoad { offset: (16+1*ptrsz) }
	len10, ok10 := i.module.Memory().ReadUint32Le(uint32(results4 + 20))
	// The return type doesn't contain an error so we panic if one is encountered
	if !ok10 {
		panic(errors.New("failed to read length from memory"))
	}
	// StringLift
	buf11, ok11 := i.module.Memory().Read(ptr9, len10)
	// The return type doesn't contain an error so we panic if one is encountered
	if !ok11 {
		panic(errors.New("failed to read bytes from memory"))
	}
	str11 := string(buf11)
	// TupleLift { tuple: Tuple { types: [U32, F64, String] }, ty: Id { idx: 0 } }
	var value12 CustomTuple
	value12.F0 = result6
	value12.F1 = result8
	value12.F2 = str11
	// Flush { amt: 1 }
	// Return { amt: 1, func: Function { name: "custom-tuple-func", kind: Freestanding, params: [("t", Id(Id { idx: 1 }))], result: Some(Id(Id { idx: 1 })), docs: Docs { contents: None }, stability: Unknown } }
	return value12
}

func (i *TuplesInstance) AnonymousTupleFunc(
	ctx context.Context,
	t struct{F0 uint32; F1 float64; F2 string},
) struct{F0 uint32; F1 float64; F2 string} {
	arg0 := t
	// GetArg { nth: 0 }
	// TupleLower { tuple: Tuple { types: [U32, F64, String] }, ty: Id { idx: 2 } }
	f00 := arg0.F0
	f01 := arg0.F1
	f02 := arg0.F2
	// I32FromU32
	result1 := api.EncodeU32(f00)
	// CoreF64FromF64
	result2 := api.EncodeF64(float64(f01))
	// StringLower { realloc: Some("cabi_realloc") }
	memory3 := i.module.Memory()
	realloc3 := i.module.ExportedFunction("cabi_realloc")
	ptr3, len3, err3 := writeString(ctx, f02, memory3, realloc3)
	// The return type doesn't contain an error so we panic if one is encountered
	if err3 != nil {
		panic(err3)
	}
	// CallWasm { name: "anonymous-tuple-func", sig: WasmSignature { params: [I32, F64, Pointer, Length], results: [Pointer], indirect_params: false, retptr: true } }
	raw4, err4 := i.module.ExportedFunction("anonymous-tuple-func").Call(ctx, uint64(result1), uint64(result2), uint64(ptr3), uint64(len3))
	// The return type doesn't contain an error so we panic if one is encountered
	if err4 != nil {
		panic(err4)
	}

	// The cleanup via `cabi_post_*` cleans up the memory in the guest. By
	// deferring this, we ensure that no memory is corrupted before the function
	// is done accessing it.
	defer func() {
		if _, err := i.module.ExportedFunction("cabi_post_anonymous-tuple-func").Call(ctx, raw4...); err != nil {
			// If we get an error during cleanup, something really bad is
			// going on, so we panic. Also, you can't return the error from
			// the `defer`
			panic(errors.New("failed to cleanup"))
		}
	}()

	results4 := raw4[0]
	// I32Load { offset: 0 }
	value5, ok5 := i.module.Memory().ReadUint32Le(uint32(results4 + 0))
	// The return type doesn't contain an error so we panic if one is encountered
	if !ok5 {
		panic(errors.New("failed to read i32 from memory"))
	}
	// U32FromI32
	result6 := api.DecodeU32(uint64(value5))
	// F64Load { offset: 8 }
	value7, ok7 := i.module.Memory().ReadUint64Le(uint32(results4 + 8))
	// The return type doesn't contain an error so we panic if one is encountered
	if !ok7 {
		panic(errors.New("failed to read f64 from memory"))
	}
	// F64FromCoreF64
	result8 := api.DecodeF64(value7)
	// PointerLoad { offset: 16 }
	ptr9, ok9 := i.module.Memory().ReadUint32Le(uint32(results4 + 16))
	// The return type doesn't contain an error so we panic if one is encountered
	if !ok9 {
		panic(errors.New("failed to read pointer from memory"))
	}
	// LengthLoad { offset: (16+1*ptrsz) }
	len10, ok10 := i.module.Memory().ReadUint32Le(uint32(results4 + 20))
	// The return type doesn't contain an error so we panic if one is encountered
	if !ok10 {
		panic(errors.New("failed to read length from memory"))
	}
	// StringLift
	buf11, ok11 := i.module.Memory().Read(ptr9, len10)
	// The return type doesn't contain an error so we panic if one is encountered
	if !ok11 {
		panic(errors.New("failed to read bytes from memory"))
	}
	str11 := string(buf11)
	// TupleLift { tuple: Tuple { types: [U32, F64, String] }, ty: Id { idx: 2 } }
	var value12 struct{F0 uint32; F1 float64; F2 string}
	value12.F0 = result6
	value12.F1 = result8
	value12.F2 = str11
	// Flush { amt: 1 }
	// Return { amt: 1, func: Function { name: "anonymous-tuple-func", kind: Freestanding, params: [("t", Id(Id { idx: 2 }))], result: Some(Id(Id { idx: 2 })), docs: Docs { contents: None }, stability: Unknown } }
	return value12
}

