// Code generated by arcjet-gravity; DO NOT EDIT.

package resources

import "context"
import "errors"
import "github.com/tetratelabs/wazero"
import "github.com/tetratelabs/wazero/api"
import "sync"

import _ "embed"

//go:embed resources.wasm
var wasmFileResources []byte

// ifaceFooerHandle is a handle to the fooer resource in the iface interface.
type ifaceFooerHandle uint32

type IfaceFooer interface {
	GetX(ctx context.Context) uint32
	SetX(ctx context.Context, x uint32)
	GetY(ctx context.Context) string
	SetY(ctx context.Context, y string)
}

type IResourcesIface[TIfaceFooerValue any, PTIfaceFooer PIfaceFooer[TIfaceFooerValue]] interface {
	NewFooer(ctx context.Context, x uint32, y string) TIfaceFooerValue
}

// PIfaceFooer constrains a pointer to a type implementing the IfaceFooer interface.
type PIfaceFooer[TIfaceFooerValue any] interface {
	*TIfaceFooerValue
	IfaceFooer
}

// ifaceFooerResourceTable is a resource table for fooer resources from the iface interface.
type ifaceFooerResourceTable[TIfaceFooerValue any, PTIfaceFooer PIfaceFooer[TIfaceFooerValue]] struct {
	mu sync.Mutex
	nextHandle uint32
	table map[ifaceFooerHandle]*TIfaceFooerValue
}

func newIfaceFooerResourceTable[TIfaceFooerValue any, PTIfaceFooer PIfaceFooer[TIfaceFooerValue]]() *ifaceFooerResourceTable[TIfaceFooerValue, PTIfaceFooer] {
	return &ifaceFooerResourceTable[TIfaceFooerValue, PTIfaceFooer]{
		nextHandle: 1,
		table: make(map[ifaceFooerHandle]*TIfaceFooerValue),
	}
}

// Store adds a resource to the table and returns its handle.
func (t *ifaceFooerResourceTable[TIfaceFooerValue, PTIfaceFooer]) Store(resource TIfaceFooerValue) ifaceFooerHandle {
	t.mu.Lock()
	defer t.mu.Unlock()
	handle := ifaceFooerHandle(t.nextHandle)
	t.nextHandle++
	t.table[handle] = &resource
	return handle
}

// get returns a pointer to the resource from the table by its handle.
func (t *ifaceFooerResourceTable[TIfaceFooerValue, PTIfaceFooer]) get(handle ifaceFooerHandle) (PTIfaceFooer, bool) {
	t.mu.Lock()
	defer t.mu.Unlock()
	resource, ok := t.table[handle]
	if !ok {
		var zero PTIfaceFooer
		return zero, false
	}
	return resource, true
}

// Get retrieves a resource from the table by its handle.
func (t *ifaceFooerResourceTable[TIfaceFooerValue, PTIfaceFooer]) Get(handle ifaceFooerHandle) (TIfaceFooerValue, bool) {
	t.mu.Lock()
	defer t.mu.Unlock()
	resource, ok := t.table[handle]
	if !ok {
		var zero TIfaceFooerValue
		return zero, false
	}
	return *resource, true
}

// Remove deletes a resource from the table.
func (t *ifaceFooerResourceTable[TIfaceFooerValue, PTIfaceFooer]) Remove(handle ifaceFooerHandle) {
	t.mu.Lock()
	defer t.mu.Unlock()
	delete(t.table, handle)
}

type ResourcesFactory[TIfaceFooerValue any, PTIfaceFooer PIfaceFooer[TIfaceFooerValue]] struct {
	runtime wazero.Runtime
	module wazero.CompiledModule
	IfaceFooerResourceTable *ifaceFooerResourceTable[TIfaceFooerValue, PTIfaceFooer]
}

func NewResourcesFactory[TIfaceFooerValue any, PTIfaceFooer PIfaceFooer[TIfaceFooerValue]](
	ctx context.Context,
	iface IResourcesIface[TIfaceFooerValue, PTIfaceFooer],
) (*ResourcesFactory[TIfaceFooerValue, PTIfaceFooer], error) {
	wazeroRuntime := wazero.NewRuntime(ctx)
	// Initialize resource tables before host module instantiation
	ifaceFooerResourceTable := newIfaceFooerResourceTable[TIfaceFooerValue, PTIfaceFooer]()
	// Instantiate import host modules
	_, err0 := wazeroRuntime.NewHostModuleBuilder("arcjet:resources/iface").
	NewFunctionBuilder().
	WithFunc(func(
		ctx context.Context,
		mod api.Module,
		arg0 uint32,
		arg1 uint32,
		arg2 uint32,
	) uint32{
		// GetArg { nth: 0 }
		// U32FromI32
		result0 := api.DecodeU32(uint64(arg0))
		// GetArg { nth: 1 }
		// GetArg { nth: 2 }
		// StringLift
		buf1, ok1 := mod.Memory().Read(arg1, arg2)
		if !ok1 {
			panic(errors.New("failed to read bytes from memory"))
		}
		str1 := string(buf1)
		// CallInterface { func: Function { name: "[constructor]fooer", kind: Constructor(Id { idx: 0 }), params: [("x", U32), ("y", String)], result: Some(Id(Id { idx: 1 })), docs: Docs { contents: None }, stability: Unknown }, async_: false }
		value2 := iface.NewFooer(ctx, result0, str1)
		// HandleLower { handle: Own(Id { idx: 0 }), name: "fooer", ty: Id { idx: 1 } }
		converted3 := uint32(ifaceFooerResourceTable.Store(value2))
		// Return { amt: 1, func: Function { name: "[constructor]fooer", kind: Constructor(Id { idx: 0 }), params: [("x", U32), ("y", String)], result: Some(Id(Id { idx: 1 })), docs: Docs { contents: None }, stability: Unknown } }
		return converted3
	}).
	Export("[constructor]fooer").
	NewFunctionBuilder().
	WithFunc(func(
		ctx context.Context,
		mod api.Module,
		arg0 uint32,
	) uint32{
		// GetArg { nth: 0 }
		// HandleLift { handle: Borrow(Id { idx: 0 }), name: "fooer", ty: Id { idx: 2 } }
		converted0 := ifaceFooerHandle(arg0)
		// CallInterface { func: Function { name: "[method]fooer.get-x", kind: Method(Id { idx: 0 }), params: [("self", Id(Id { idx: 2 }))], result: Some(U32), docs: Docs { contents: None }, stability: Unknown }, async_: false }
		resource1, ok1 := ifaceFooerResourceTable.get(converted0)
		if !ok1 {
			panic("invalid resource handle")
		}
		value1 := resource1.GetX(ctx)
		// I32FromU32
		result2 := value1
		// Return { amt: 1, func: Function { name: "[method]fooer.get-x", kind: Method(Id { idx: 0 }), params: [("self", Id(Id { idx: 2 }))], result: Some(U32), docs: Docs { contents: None }, stability: Unknown } }
		return result2
	}).
	Export("[method]fooer.get-x").
	NewFunctionBuilder().
	WithFunc(func(
		ctx context.Context,
		mod api.Module,
		arg0 uint32,
		arg1 uint32,
	) {
		// GetArg { nth: 0 }
		// HandleLift { handle: Borrow(Id { idx: 0 }), name: "fooer", ty: Id { idx: 2 } }
		converted0 := ifaceFooerHandle(arg0)
		// GetArg { nth: 1 }
		// U32FromI32
		result1 := api.DecodeU32(uint64(arg1))
		// CallInterface { func: Function { name: "[method]fooer.set-x", kind: Method(Id { idx: 0 }), params: [("self", Id(Id { idx: 2 })), ("x", U32)], result: None, docs: Docs { contents: None }, stability: Unknown }, async_: false }
		resource2, ok2 := ifaceFooerResourceTable.get(converted0)
		if !ok2 {
			panic("invalid resource handle")
		}
		resource2.SetX(ctx, result1)
		// Return { amt: 0, func: Function { name: "[method]fooer.set-x", kind: Method(Id { idx: 0 }), params: [("self", Id(Id { idx: 2 })), ("x", U32)], result: None, docs: Docs { contents: None }, stability: Unknown } }
	}).
	Export("[method]fooer.set-x").
	NewFunctionBuilder().
	WithFunc(func(
		ctx context.Context,
		mod api.Module,
		arg0 uint32,
		arg1 uint32,
	) {
		// GetArg { nth: 0 }
		// HandleLift { handle: Borrow(Id { idx: 0 }), name: "fooer", ty: Id { idx: 2 } }
		converted0 := ifaceFooerHandle(arg0)
		// CallInterface { func: Function { name: "[method]fooer.get-y", kind: Method(Id { idx: 0 }), params: [("self", Id(Id { idx: 2 }))], result: Some(String), docs: Docs { contents: None }, stability: Unknown }, async_: false }
		resource1, ok1 := ifaceFooerResourceTable.get(converted0)
		if !ok1 {
			panic("invalid resource handle")
		}
		value1 := resource1.GetY(ctx)
		// GetArg { nth: 1 }
		// StringLower { realloc: Some("cabi_realloc") }
		memory2 := mod.Memory()
		realloc2 := mod.ExportedFunction("cabi_realloc")
		ptr2, len2, err2 := writeString(ctx, value1, memory2, realloc2)
		if err2 != nil {
			panic(err2)
		}
		// LengthStore { offset: ptrsz }
		mod.Memory().WriteUint32Le(uint32(arg1+4), uint32(len2))
		// PointerStore { offset: 0 }
		mod.Memory().WriteUint32Le(uint32(arg1+0), uint32(ptr2))
		// Return { amt: 0, func: Function { name: "[method]fooer.get-y", kind: Method(Id { idx: 0 }), params: [("self", Id(Id { idx: 2 }))], result: Some(String), docs: Docs { contents: None }, stability: Unknown } }
	}).
	Export("[method]fooer.get-y").
	NewFunctionBuilder().
	WithFunc(func(
		ctx context.Context,
		mod api.Module,
		arg0 uint32,
		arg1 uint32,
		arg2 uint32,
	) {
		// GetArg { nth: 0 }
		// HandleLift { handle: Borrow(Id { idx: 0 }), name: "fooer", ty: Id { idx: 2 } }
		converted0 := ifaceFooerHandle(arg0)
		// GetArg { nth: 1 }
		// GetArg { nth: 2 }
		// StringLift
		buf1, ok1 := mod.Memory().Read(arg1, arg2)
		if !ok1 {
			panic(errors.New("failed to read bytes from memory"))
		}
		str1 := string(buf1)
		// CallInterface { func: Function { name: "[method]fooer.set-y", kind: Method(Id { idx: 0 }), params: [("self", Id(Id { idx: 2 })), ("y", String)], result: None, docs: Docs { contents: None }, stability: Unknown }, async_: false }
		resource2, ok2 := ifaceFooerResourceTable.get(converted0)
		if !ok2 {
			panic("invalid resource handle")
		}
		resource2.SetY(ctx, str1)
		// Return { amt: 0, func: Function { name: "[method]fooer.set-y", kind: Method(Id { idx: 0 }), params: [("self", Id(Id { idx: 2 })), ("y", String)], result: None, docs: Docs { contents: None }, stability: Unknown } }
	}).
	Export("[method]fooer.set-y").
	NewFunctionBuilder().
	WithFunc(func(ctx context.Context, mod api.Module, arg0 uint32) {
		// [resource-drop]: called when guest drops a resource
		//
		// With borrow-only parameters, guests never take ownership of host resources.
		// Resources stay in host table until host explicitly removes them.
		// This callback is a no-op since host controls the full lifecycle.
		//
		// Note: If we add owned parameter support in the future, this would need
		// to implement ref-counting and state tracking to properly cleanup consumed resources.
		_ = arg0
	}).
	Export("[resource-drop]fooer").
	Instantiate(ctx)
	if err0 != nil {
		return nil, err0
	}
	// Instantiate export resource management host modules
	// Compiling the module takes a LONG time, so we want to do it once and hold
	// onto it with the Runtime
	module, err := wazeroRuntime.CompileModule(ctx, wasmFileResources)
	if err != nil {
		return nil, err
	}
	return &ResourcesFactory[TIfaceFooerValue, PTIfaceFooer]{
		runtime: wazeroRuntime,
		module: module,
		IfaceFooerResourceTable: ifaceFooerResourceTable,
	}, nil
}

func (f *ResourcesFactory[TIfaceFooerValue, PTIfaceFooer]) Instantiate(ctx context.Context) (*ResourcesInstance[TIfaceFooerValue, PTIfaceFooer], error) {
	if module, err := f.runtime.InstantiateModule(ctx, f.module, wazero.NewModuleConfig()); err != nil {
		return nil, err
	} else {
		return &ResourcesInstance[TIfaceFooerValue, PTIfaceFooer]{
			module: module,
			IfaceFooerResourceTable: f.IfaceFooerResourceTable,
		}, nil
	}
}

func (f *ResourcesFactory[TIfaceFooerValue, PTIfaceFooer]) Close(ctx context.Context) {
	f.runtime.Close(ctx)
}

type ResourcesInstance[TIfaceFooerValue any, PTIfaceFooer PIfaceFooer[TIfaceFooerValue]] struct {
	module api.Module
	IfaceFooerResourceTable *ifaceFooerResourceTable[TIfaceFooerValue, PTIfaceFooer]
}

func (i *ResourcesInstance[TIfaceFooerValue, PTIfaceFooer]) Close(ctx context.Context) error {
	if err := i.module.Close(ctx); err != nil {
		return err
	}

	return nil
}

// writeString will put a Go string into the Wasm memory following the Component
// Model calling convetions, such as allocating memory with the realloc function
func writeString(
	ctx context.Context,
	s string,
	memory api.Memory,
	realloc api.Function,
) (uint64, uint64, error) {
	if len(s) == 0 {
		return 1, 0, nil
	}

	results, err := realloc.Call(ctx, 0, 0, 1, uint64(len(s)))
	if err != nil {
		return 1, 0, err
	}
	ptr := results[0]
	ok := memory.Write(uint32(ptr), []byte(s))
	if !ok {
		return 1, 0, err
	}
	return uint64(ptr), uint64(len(s)), nil
}

func (i *ResourcesInstance[TIfaceFooerValue, PTIfaceFooer]) UseFooer(
	ctx context.Context,
	foo ifaceFooerHandle,
) {
	arg0 := foo
	// GetArg { nth: 0 }
	// HandleLower { handle: Borrow(Id { idx: 3 }), name: "fooer", ty: Id { idx: 4 } }
	converted0 := uint32(arg0)
	// CallWasm { name: "use-fooer", sig: WasmSignature { params: [I32], results: [], indirect_params: false, retptr: false } }
	_, err1 := i.module.ExportedFunction("use-fooer").Call(ctx, uint64(converted0))
	// The return type doesn't contain an error so we panic if one is encountered
	if err1 != nil {
		panic(err1)
	}

	// Return { amt: 0, func: Function { name: "use-fooer", kind: Freestanding, params: [("foo", Id(Id { idx: 4 }))], result: None, docs: Docs { contents: None }, stability: Unknown } }
}

func (i *ResourcesInstance[TIfaceFooerValue, PTIfaceFooer]) UseFooerReturnNew(
	ctx context.Context,
	foo ifaceFooerHandle,
) ifaceFooerHandle {
	arg0 := foo
	// GetArg { nth: 0 }
	// HandleLower { handle: Borrow(Id { idx: 3 }), name: "fooer", ty: Id { idx: 4 } }
	converted0 := uint32(arg0)
	// CallWasm { name: "use-fooer-return-new", sig: WasmSignature { params: [I32], results: [I32], indirect_params: false, retptr: false } }
	raw1, err1 := i.module.ExportedFunction("use-fooer-return-new").Call(ctx, uint64(converted0))
	// The return type doesn't contain an error so we panic if one is encountered
	if err1 != nil {
		panic(err1)
	}

	results1 := raw1[0]
	// HandleLift { handle: Own(Id { idx: 3 }), name: "fooer", ty: Id { idx: 5 } }
	converted2 := ifaceFooerHandle(results1)
	// Return { amt: 1, func: Function { name: "use-fooer-return-new", kind: Freestanding, params: [("foo", Id(Id { idx: 4 }))], result: Some(Id(Id { idx: 5 })), docs: Docs { contents: None }, stability: Unknown } }
	return converted2
}

