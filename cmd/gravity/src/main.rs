use std::{fmt::Write, fs, path::Path, process::ExitCode};

use clap::{Arg, ArgAction, Command};
use genco::lang::{Go, go};
use wit_bindgen_core::wit_parser::{Resolve, SizeAlign};

use arcjet_gravity::{
    codegen::{Bindings, WasmData},
    go::GoDoc,
};

// `wit_component::decode` uses `root` as an arbitrary name for the primary
// world name, see
// 1. https://github.com/bytecodealliance/wasm-tools/blob/585a0bdd8f49fc05d076effaa96e63d97f420578/crates/wit-component/src/decoding.rs#L144-L147
// 2. https://github.com/bytecodealliance/wasm-tools/issues/1315
pub const PRIMARY_WORLD_NAME: &str = "root";

fn main() -> Result<ExitCode, ()> {
    let cmd = Command::new("gravity")
        .arg(
            Arg::new("world")
                .short('w')
                .long("world")
                .help("generate host bindings for the specified world")
                .default_value(PRIMARY_WORLD_NAME),
        )
        .arg(
            Arg::new("inline-wasm")
                .long("inline-wasm")
                .help("include the WebAssembly file as hex bytes in the output code")
                .action(ArgAction::SetTrue),
        )
        .arg(
            Arg::new("file")
                .help("the WebAssembly file to process")
                .required(true),
        )
        .arg(
            Arg::new("wit-file")
                .long("wit-file")
                .help("the WIT file to process. If not provided, the WIT file will be loaded from the WebAssembly file. Must match, or weird things may happen. This mostly exists to support docs, which don't seem to be persisted to the WebAssembly file.")
                .required(false),
        )
        .arg(
            Arg::new("output")
                .help("the file path where output generated code should be output")
                .short('o')
                .long("output"),
        );

    let matches = cmd.get_matches();
    let selected_world = matches
        .get_one::<String>("world")
        .expect("should have a world");
    let file = matches
        .get_one::<String>("file")
        .expect("should have a file");
    let inline_wasm = matches.get_flag("inline-wasm");
    let output = matches.get_one::<String>("output");

    // Load the file specified as the `file` arg to clap
    let wasm = match fs::read(file) {
        Ok(wasm) => wasm,
        Err(_) => {
            eprintln!("unable to read file: {file}");
            return Ok(ExitCode::FAILURE);
        }
    };

    let (module, mut bindgen) = wit_component::metadata::decode(&wasm)
        // If the Wasm doesn't have a custom section, None will be returned so we need to use the original
        .map(|(module, bindgen)| (module.unwrap_or(wasm), bindgen))
        .expect("file should be a valid WebAssembly module");

    let wit_file = matches.get_one::<String>("wit-file");
    if let Some(wit_file) = wit_file {
        let mut resolve = Resolve::new();
        if let Err(e) = resolve.push_path(wit_file) {
            eprintln!("unable to parse WIT file: {wit_file}: {e}");
            return Ok(ExitCode::FAILURE);
        }
        bindgen.resolve = resolve;
    }

    let wasm_file = &format!("{}.wasm", selected_world.replace('-', "_"));

    let Some((_, world)) = bindgen
        .resolve
        .worlds
        .iter()
        .find(|(_, world)| world.name == *selected_world)
    else {
        eprintln!("unable to find world: {selected_world}");
        return Ok(ExitCode::FAILURE);
    };

    let mut sizes = SizeAlign::default();
    sizes.fill(&bindgen.resolve);
    let mut bindings = Bindings::new(&bindgen.resolve, world, &sizes);

    bindings.include_wasm(if inline_wasm {
        WasmData::Inline(&module)
    } else {
        WasmData::Embedded(wasm_file)
    });

    bindings.generate();

    let mut header = "// Code generated by arcjet-gravity; DO NOT EDIT.\n\n".to_string();
    write!(header, "{}", GoDoc::new(world.docs.contents.clone())).unwrap();
    let mut w = genco::fmt::FmtWriter::new(header);
    let fmt = genco::fmt::Config::from_lang::<Go>().with_indentation(genco::fmt::Indentation::Tab);
    let config = go::Config::default().with_package(selected_world.replace('-', "_"));

    // TODO(#16): Don't use the internal bindings.out field
    bindings
        .out
        .format_file(&mut w.as_formatter(&fmt), &config)
        .unwrap();

    match output {
        Some(outpath) => {
            if !inline_wasm {
                let wasm_outpath = Path::new(outpath).with_file_name(wasm_file);
                match fs::write(&wasm_outpath, module) {
                    Ok(_) => (),
                    Err(_) => {
                        eprintln!("failed to create file: {}", wasm_outpath.to_string_lossy());
                        return Ok(ExitCode::FAILURE);
                    }
                }
            }
            match fs::write(outpath, w.into_inner()) {
                Ok(_) => Ok(ExitCode::SUCCESS),
                Err(_) => {
                    eprintln!("failed to create file: {outpath}");
                    Ok(ExitCode::FAILURE)
                }
            }
        }
        None => {
            println!("{}", w.into_inner());
            Ok(ExitCode::SUCCESS)
        }
    }
}
